
一、JVM简介
虚拟机：（VMWare/Virtual ）
通过软件模拟的具有完整硬件功能、运行在完全隔离环境中的计算机系统。

JVM是通过软件模拟java字节码指令集，jvm只保留了PC寄存器，而普遍的虚拟机有很多寄存器

从JDK1 . 3至今，HotSpot 为默认JVM

JVM内存区域划分--->判断对象是否存活-->垃圾回收算法-->垃圾回收器-->JVM性能检测

线程私有内存：1.程序计数器（不会OOM）    2.虚拟机   3 .本地方法
线程共享内存：1. 堆   2 . 方法区   3.运行时常量池
私有内存：生命周期与具体线程相同，随着线程的创建而创建，随着线程销毁，对应空间回收
三、JVM内存区域划分-共6块内存

3 . 1 线程私有内存：每个线程都有，彼此之间完全隔离。
3 . 1 . 1程序计数器
--程序计数器是比较小的内存空间，当前线程所执行的字节码的行号指示器。
若当前线程执行的是Java方法，计数器记录的是正在执行的JVM字节码指令地址；
若当前线程执行的是Native方法，计时器值为空；

程序计数器是唯一一块不会产生OOM异常的区域；

3 . 1 . 2 虚拟机--Java方法执行的内存模型
虚拟机Ｃ枋java方法执行的内存模型。

每个方法执行的同时都会创建一个Ｖ〈娲⒕植勘淞勘怼⒉僮魇！⒎椒ǔ隹诘刃畔。每个方法从调用直到执行完毕的过程，对应一个Ｖ≡谛槟饣的入栈与出栈过程。

声明周期与线程相同 ：在创建线程时同时创建此线程的虚拟机＃线程执行结束，虚拟机Ｓ胂叱桃煌被回收。

此区域一共会产生两种异常：
1  . 若线程请求的Ｉ疃却笥JVM允许的深度（-Xss设置Ｈ萘浚，抛出StackOverFlowError（Ｒ绯觯┮斐！＃ǖハ叱蹋
2 . 虚拟机在进行５亩态扩展时，若无法申请到足够内存，抛出OOM（OutOfMemoryError）异常。（多线程）

3 . 1 .3本地方法＃ㄓ胄槟饣Ｍ耆类似，方法不同）
本地方法（native方法）执行的内存模型

在HotSpot虚拟机中，本地方法Ｓ胄槟饣Ｊ峭一块内存区域。

线程共享内存：所有线程共享此内存空间，此空间对所有线程可见。

3 . 1 . 4  堆（GC堆）
Java堆（java Heap ）
是JVM管理的最大内存区域。在JVM启动时创建，所有线程共享此线程，此内存中存放的都是对象实例以及数组。

java堆是垃圾回收器管理的最重要内存区域。java堆可以处于物理上不连续的内存空间。 -Xmx设置堆最大值
-Xms设置堆最小值 

若在堆中没有足够的内存完整实例分配并且堆无法再次扩展时，抛出OOM异常

OOM：
内存溢出：内存中的对象确实还应该存活，但由于堆内存不够用产生的异常。
内存泄漏：无用对象无法被GC


3 . 1. 5  方法区
用于存储已被加载的类信息、常量、静态变量等数据，JDK8以前，方法区也叫永久代，JDK8之后称为元空间（Meta Space）

方法区无法满足内存分配需求时，抛出OOM

3 . 1 . 6 运行时常量池
运行时常量池方法区的一部分，存放字面与符号引用。

字面量：字符串常量（JDK1.7移到堆中）、final常量、基本数据类型的值。

符号引用： 类、字段、方法的完全限定名、名称、描述符


4 . 判断对象是否已死

4 . 1  引用计数法

算法思想：给每个对象附加一个引用计数器，每当有一个地方引用此对象时，计数器+1；每当有一个引用失效时，引用-1；在任意时刻，只要计数器值为0的对象就是不能再被使用的，即对象已死。

引用计数器法实现简单，判断效率也较高，Python使用引用计数器法来管理内存。但是无法解决循环引用问题

JVM并未采用此算法

4 . 2可达性分析算法

JVM采用可达性分析算法来判断对象是否存活（c#、Lisp）

核心思想：
通过一系列“GC Roots”的对象作为起点，从这些节点开始向下搜索对象，搜素走过的路径，称为“引用链”，当一个对象到任意一个GC Roots对象没有任何的引用链相连时（从GC Roots到达对象不可达），证明对象已死。

java中能作为GC Roots 的对象包含以下四种：
1 . 虚拟机Ｖ幸用的对象
2 . 类静态变量引用的对象
3 . 常量引用的对象
4 . 本地方法Ｖ幸用的对象   

*******JDK 1 . 2之后对于引用的概念做了扩充*******

-XX:+PrintGC   :打印具体的回收日志

将引用分为强引用（Strong Reference）、软引用（soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference ）四种，这四种强度依次递减。

1 . 强引用：强引用指的是代码中普遍存在的，类似于Object obj = new Object（）；
   在JVM中只要强引用还存在，垃圾回收器永远不会回收此对象实例。

2 . 软引用（设计到缓存的时候）：软引用用来描述一些有用但不必须对象。对于仅被软引用指向的对象，在系统将要发生内存溢出之前，会将所有软引用对象进行垃圾回收。若内存够用，这些对象仍然保留，在JDK 1 . 2之后提供SoftReference来实现软引用。

3 . 弱引用：弱引用强度比软引用更差一点。仅被弱引用关联的对象最多只能生存到下一次GC开始之前。当垃圾回收器开始工作时，无论当前内存是否够用，都会回收掉仅被弱引用关联的对象。JDK1 . 2之后，使用WeakRerence来实现弱引用。

4 . 虚引用：虚引用也称为幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间产生影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是在这个对象被GC之前，收到一个系统通知。JDK1 . 2之后，提供PhantomReference来描述虚引用。


4 . 3 对象的自我拯救-finalize
protected void finalize（） throws Throwable{}

在可达性分析算法中不可达的对象，也并非“非死不可”，所有不可达的对象处于“缓刑”阶段

要宣告一个对象的彻底死亡，需要经历俩次标记过程：

--若对象在进行可达性分析之后发现到GC Roots不可达，此对象会进行第一次标记并且进行一次筛选过程。筛选的条件是此对象是否有必要执行finalize（）。当对象没有覆盖finalize（）方法或finalize（）方法已被调用过了，JVM会将此对象彻底宣判死亡。 

筛选成功（对象覆写了finalize方法并且未被执行），会将此对象放在F-Queue，如果对象在finalize（）成功自救（此对象与GC Roots建立联系），则对象会在第二次标记时被移除回收集合，成功存活；若对象在finalize中仍与GC Roots不可达，宣告死亡。

4 . 4 回收方法区（GC的可能性很小）
方法区的回收主要回收两部分内容：废弃常量和无用的类

判断一个类是无用类，必须满足一下三个条件：
--i . 该类的所有实例都已经被回收（java 堆中不存在该类的任何实例）
--ii . 加载该类的类加载器（ClassLoaol）已经被回收
--iii . 该类的Class 对象没有任何其他地方被引用，也无法通过反射访问该类的所有内容


5 .垃圾回收算法


标记-清除：会产生大量不连续空间碎片
复制收集算法：利用 率低
 新生代复制算法：大部分对象都朝生夕死，所以不需要按照1:1的比例来划分内存空间，而是将新生代内存划分为较大的Eden区和俩块较小的Survivor区域（默认为8:1:1），每次使用Eden与一块Survivor区域，在发生GC时，将使用区域的存活对象复制到另一块Survivror区域，最后清理掉Eden和刚才用过的Survivor空间。

当Survivor空间不够用时，需要依赖其他内存（老年代）进行分配担保

HotSpot（现代商用虚拟机）实现的复制算法流程如下：

1 . 当Eden区满的时候，会触发第一次Minor GC，把还活着的对象拷贝到Survivor From区；当Eden区再次处罚Minor GC的时候，会扫描Eden区和From区域，对这俩个区域进行垃圾回收，经过这次回收后还存活的对象，则直接复制到To区域，并将Eden和From区域清空。

2 . 当后续Eden又发生Minor GC的时候，会对Eden和To区域进行垃圾回收，存活的对象复制到From区域，并将Eden和To区域清空

3 . 部分对象会在From和To区域中复制来复制去，如此交换15次（由JVM参数Max Tenuring Threshold决定 这个参数默认是15），最终如果还是存活，就存入到老年代

老年代标记-整理算法

分代收集算法：
一般把java堆分为新生代和老年代。在新生代中，每次垃圾回收都有大批对象死去，只有少量存活，因此我们采用复制算法；而老年代中对象存活率高、没有额外空间对它进行分配担保，就必须采用“标记-清理”或者“标记-整理”算法。

面试题：请问了解Minor GC 和Full GC 吗，这俩种GC有什么不一样？
1 .  Minor GC 又称为新生代GC :指的是发生在新生代的垃圾收集。因为java对象大多都是具备朝生夕死的特性，因此Minor GC （采用复制算法）非常频繁，一般回收速度也比较快。

2 . Full GC又称为老年代 GC 或者 Major GC ：指发生在老年代的垃圾收集。出现了Major GC ，经常会伴随至少一次的Minor GC （并非绝对，在Parallel Scavenge 收集器中就有直接进行Full GC 的策略选择过程）。Major GC 的速度一般会比Minor GC 慢10倍以上。




内存分配 策略：
对象优先在Eden区产生
大对象（大数组）直接进入老年代
在新生代长期存活的对象进入老年代
动态年龄判定







5 . JDK命令行工具

5 . 1    jps：JVM 进程状态工具
列出正在运行的JVM进程，并返回进程ID

5 . 4   jmap ：内存映像工具（查看java堆具体信息）******
jamp 用于生成堆转储快照（堆的快照）

jamp  -heap PID：显示jvm堆具体信息
jamp  -histo POD : 显示jvm中对象的统计信息


5 . 5  ：jhat：heap文件的分析工具
jhat heap 文件路径

5 . 6 jstack  java 堆栈跟踪工具******
jstack 生成当前JVM线程的快照
可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环等问题



6 . java内存模型（JMM）--基于线程的内存模型
JMM定义的主要目标为了定义程序中各个变量的访问规则（JVM如何将变量从内存中取出以及如何将变量再写回内存等细节）。此处的变量包括实例字段、静态字段与数组元素。
6 . 1 主内存（所有线程共享）与工作内存（每个线程独有）
a . JMM规定所有变量必须存储在主内存中。b. 每条线程都有自己的工作内存，线程中工作内存中保存了该线程使用到的变量的主内存副本。c . 线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，不能直接读写主内存变量。d. 不同线程之间也无法直接访问彼此的工作内存变量，线程间变量值的传递均需要通过主内存来完成。


ACID（事物的四大特性）
A：原子性：事物中的一组操作要么全部发生要么全部都不发生
C：一致性：数据库从一个一致性状态到另一个一致性状态
I：隔离性：不同事物之间是相互隔离的，看不到彼此事物数据的变化
D：持久性：一旦事物被提交，他对数据库的操作就是永久的，不可在变

6 . 2 内存间相互操作

JMM内存三大特性

原子性：基本数据类型的访问和读写是具备原子性的；如若需要更大范围的原子性，需要内建锁或lock体系的支持（i++，i--等操作）（一个或多个操作在在执行过程中不被打乱）；

 
可见性：  当一个线程修改了共享变量的值，其他线程能够立即得知此修改。 volatile、final、synchronized可以实现可见性

有序性： 若在本线程内观察，所有操作都是有序的；若在线程之外观察另一个线程，所有操作都是无序的。

JMM具备先天的有序性，即无须通过任何手段就能保证的有序性。称为JMM的happens - before原则。若俩个操作的次序无法从happens - before中推导出来，则无法保证其有序性，JVM可以随意对其进行重排序。

要想并发程序正确的执行，必须同时保证原子性、可见性、以及有序性。只要其中任意一个没有被保证，就有可能导致程序运行不正确。

volatile 变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作。

6 . 3 volatile 变量的使用规则
第一：保证此变量对所有线程的可见性
当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量无法做到可见性

volatile变量在各个线程中是一致的，但是volatile变量的运算在并发下一样是不安全的。Java中运算操作并非原子性操作，必须结合内建锁或lock体系来约束。

由于volatile只保证可见性，在不符合以下俩条规则的场景下，仍然需要使用加锁来保证原子性：
I . 运算结果不依赖当前变量的值，或者能够确保只有单一的线程修改变量值。
II . 变量不需要与其他的状态变量共同参与不变约束。

并发场景下对于类似i++操作如何保证程序的正确结果：
1 . 加锁
2 . 使用原子类（java.util.atomic 包下的所有类-内部使用CAS保证原子性）

第二：禁止指令重排（内存屏障--一堵墙）
a、当程序执行到volatile变量的读或写操作时，在其前面的操作更改肯定全部已经执行完毕且结果已经对后面的操作可见，在其后面的操作肯定还没有执行

b、在进行指令优化时，不能将对vollatile变量访问的语句放在其后面执行，也不能提前执行。

懒汉式单例模式的线程问题：
new Singleton() 以上做了三件事
1-在堆上分配空间
2-属性初始化
3-引用指向对象

有可能出现 1-3-2;
在多线程中，singleton的引用已经不为null

1-在堆上分配空间
//线程1
3-引用指向对象(singleton已经不为null) 导致判断失效，使得属性值还未初始化，使得取出来的值null;

2-属性初始化

volatile作用：禁止指令重排，使得属性值一定是初始化好的。任何一个拿到对象，一定是初始化好的对象
synchronized作用：保证对象只有一个。











 